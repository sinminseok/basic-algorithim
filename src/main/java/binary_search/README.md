### 이진탐색(BinarySearch)

-----
이진 탐색은 업다운 게임에서 계속 남아 있는 범위의 가운데 숫자를 부르는 것 처럼 남은 범위를 계속해서 
반으로 나눈다. 나눈 두 범위에서 한쪽은 정답이 있고, 다른 한쪽은 정답이 없다는 것을 이용해 효율적인
탐색을 이어갑니다. 이진탐색도 마찬가지로 가운데를 기준으로 대소 관계를 비교해 절반씩 줄여 나아가며 값을 
탐색하는 효율적인 탐색 알고리즘이다.

이진 탐색을 진행하려면 배열이 정렬되어 있어야 하고, 많은 경우 우리가 직접 데이터를 정렬해 줘야 한다.
하지만 같은 데이터라고 하더라도 여러가지 정렬 방법이 있을 수 있다. 정렬수라면 가장 기본적인 오름차순, 내림차순
은 물론 사전 순,자릿수 순, 모든 자릿수의 합 순 등 다양한 정렬 방법이 있다. 심지어는 
정렬할 수 있는 데이터 없이 직접 정렬 규칙을 찾아내어 이진 탐색을 적용할 때 도 있다.

#### 정렬 방식 선택하기

이진 탐색을 위해서는 아무 정렬 방식이나 선택해선 안된다. 중간 값과 정답의 대소를 명확히 구분할 수 있어야 하고, 대소 비교를 하여
정답이 속한 더 작은 범위를 정확히 파악할 수 있어야 한다. 모든 자릿수 합이 15인 숫자를 찾는데 오름차순으로 정렬하고
이진 탐색을 적용할 순 없다. 따라서 이진 탐색을 적용하려면 문제에서 요구하는 조건을 정확히 파악하고, 이에 따른
대소 비교를 구현하여 데이터를 정렬한 후 진행해야 한다.

#### 정렬 규칙 찾기

이진 탐색 문제 대부분은 배열이나 리스트를 주고 원소를 찾기보다는, 큰 범위의 정답 후보 중 문제 조건에 맞는 정답을
찾아낼 때가 많다. 이때는 문제에서 요구하는 조건의 검사 결과가 정답 후보의 값에 따라 정렬된 상태가 되는지 확인 해야한다.

#### 이진 탐색 범위 표기법
| 찾고자 하는 값                | 범위 표기법      |
|-------------------------|-------------|
| 정답 조건을 만족하는 값 중 가장 큰 값  | [start,end) |
| 정답 조건을 만족하는 값 중 가장 작은 값 | [start,end] |

#### 자바 이진 탐색 메서드

정렬된 배열, 리스트를 기준으로 실행시켜야 함!

| 자료 구조 | 메서드                        |
|-------|----------------------------|
| 배열    | Arrays.binarySearch()      |
| 리스트   | Collections.binarySearch() |


#### 메서드 사용 예제
```
int[] array = new int[] {1, 4, 6, 7, 8, 10, 13, 17};
List<Integer> list = List.of(1, 4, 6, 7, 8, 10, 13, 17);

//4
int arrayIndex = Arrays.binarySearch(array, 8);
//4
int listIndex = Collections.binarySearch(list, 8);
```
하지만 찾고자 하는 숫자가 없다면 음수를 반환하는데, 이 값을 이용하면 검색하려는 원소가 배열이나 리스트에서 어느 위치에 들어가야 하는지 구할 수 있다.

```
int[] array = new int[] {1, 4, 6, 7, 8, 10, 13, 17};
List<Integer> list = List.of(1, 4, 6, 7, 8, 10, 13, 17);

//-7
int arrayIndex = Arrays.binarySearch(array, 11);
//-7
int listIndex = Collections.binarySearch(list, 11);
```
음수값을 양수로 변환하고 1을 빼면 원소가 들어갈 위치가 된다 -7이 6 으로 변환되고
6은 해당 배열이나 리스트에서 들어갈 위치의 인덱스가 된다.

#### ! TIP
`하지만 코딩 테스트에서는 배여링나 리스트로 탐색 공간을 표현할 수 없는 경우처럼 내장 이진 메서드를 적용할 수 없을때가 
많으므로 이진 탐색 구현 방법을 꼭 익혀두자.`

### 구현 코드

----
```
private static int binarySearch(int[] arr, int target){
    int start = 0;
    int end = arr.length;
    
    while(end > start){
        int mid = (start + end) / 2;
        int value = arr[mid];
        
        if(value == target){
            return mid;
        }else if (value > target){
            end = mid;
        }else{
            start = mid + 1;
        }
    }
    
    return -1;

}

```

